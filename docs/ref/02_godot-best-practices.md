# Godot 最佳实践指南

> 本文档基于 Godot Engine 4.x 官方最佳实践文档整理而成

## 目录

1. [前言](#前言)
2. [面向对象原则在Godot中的应用](#面向对象原则在godot中的应用)
3. [场景组织](#场景组织)
4. [何时使用场景与脚本](#何时使用场景与脚本)
5. [自动加载与常规节点](#自动加载与常规节点)
6. [数据偏好](#数据偏好)
7. [Godot接口](#godot接口)
8. [Godot通知](#godot通知)
9. [逻辑偏好](#逻辑偏好)
10. [项目组织](#项目组织)

## 前言

本最佳实践系列旨在帮助你高效地使用 Godot 引擎。Godot 在项目代码库结构和场景分解方面提供了极大的灵活性。每种方法都有其优缺点，只有在长期使用引擎后才能充分权衡。

Godot 中的最佳实践依赖于面向对象的设计原则。我们使用单一职责原则和封装等工具。

建议首先阅读"面向对象原则在Godot中的应用"，它解释了 Godot 的节点和场景如何与其他面向对象编程语言中的类和对象相关联。这将帮助你理解本系列的其余内容。

## 面向对象原则在Godot中的应用

引擎提供了两种创建可重用对象的主要方式：脚本和场景。从技术上讲，这两种方式都不在底层定义类。

尽管如此，使用 Godot 的许多最佳实践都涉及将面向对象编程原则应用于组成游戏的脚本和场景。

### 脚本在引擎中的工作原理

引擎提供了像 Node 这样的内置类。你可以使用脚本扩展这些类来创建派生类型。这些脚本在技术上不是类，而是告诉引擎对某个内置类执行一系列初始化操作的资源。

Godot 的内部类有方法将类的数据注册到 ClassDB 中。这个数据库提供运行时的类信息访问。ClassDB 包含以下类信息：
- 属性
- 方法
- 常量
- 信号

### 场景

场景的行为与类有许多相似之处，因此将场景视为类是有意义的。场景是可重用、可实例化和可继承的节点组。

创建场景类似于拥有一个创建节点并使用 `add_child()` 将它们添加为子节点的脚本。我们通常将场景与带脚本的根节点配对，该脚本利用场景中的节点。这样，脚本通过命令式代码添加行为来扩展场景。

## 场景组织

### 如何有效地建立关系

当 Godot 用户开始创建自己的场景时，他们经常遇到以下问题：

他们创建第一个场景并用内容填充它，但最终将场景的分支保存到单独的场景中，因为他们开始意识到应该拆分内容。然而，他们随后发现以前可以依赖的硬引用不再可能。在多个地方重用场景会产生问题，因为节点路径找不到目标，并且在编辑器中建立的信号连接会断开。

要解决这些问题，你必须实例化子场景，而不需要它们了解环境细节。你需要能够相信子场景会创建自己，而不会对如何使用它挑剔。

**如果可能，你应该设计场景没有依赖关系。**也就是说，你应该创建将所需的一切保留在内部的场景。如果场景必须与外部上下文交互，有经验的开发人员建议使用依赖注入。

常用的依赖注入方法：

1. **连接到信号**（极其安全，但应仅用于"响应"行为，而不是启动行为）
   ```gdscript
   # 父节点
   $Child.signal_name.connect(method_on_the_object)

   # 子节点
   signal_name.emit()  # 触发父节点定义的行为
   ```

2. **调用方法**（用于启动行为）
   ```gdscript
   # 父节点
   $Child.method_name = "do"

   # 子节点（假设它有 String 属性 'method_name' 和方法 'do'）
   call(method_name)  # 调用父节点定义的方法
   ```

3. **初始化 Callable 属性**（比方法更安全，因为不需要方法的所有权）
   ```gdscript
   # 父节点
   $Child.func_property = object_with_method.method_on_the_object

   # 子节点
   func_property.call()  # 调用父节点定义的方法（可以来自任何地方）
   ```

4. **初始化 Node 或其他 Object 引用**
   ```gdscript
   # 父节点
   $Child.target = self

   # 子节点
   print(target)  # 使用父节点定义的节点
   ```

5. **初始化 NodePath**
   ```gdscript
   # 父节点
   $Child.target_path = ".."

   # 子节点
   get_node(target_path)  # 使用父节点定义的 NodePath
   ```

这些选项隐藏了子节点的访问点，这反过来使子节点与其环境**松散耦合**。你可以在另一个上下文中重用它，而无需对其 API 进行任何额外更改。

## 何时使用场景与脚本

### 匿名类型

可以完全使用脚本单独定义场景内容。从本质上讲，这就是 Godot 编辑器在其对象的 C++ 构造函数中所做的事情。

但是，选择使用哪一个可能是一个两难的境地。创建脚本实例与创建引擎内类相同，而处理场景需要更改 API：

```gdscript
const MyNode = preload("my_node.gd")
const MyScene = preload("my_scene.tscn")

var node = Node.new()
var my_node = MyNode.new()  # 相同的方法调用
var my_scene = MyScene.instantiate()  # 不同的方法调用
var my_inherited_scene = MyScene.instantiate(PackedScene.GEN_EDIT_STATE_MAIN)  # 创建继承自 MyScene 的场景
```

### 命名类型

脚本可以在编辑器本身中注册为新类型。这在节点或资源创建对话框中将其显示为新类型，带有可选图标。这样，用户使用脚本的体验更加简化。

有两种注册类型的系统：

1. **自定义类型**
   - 仅编辑器可用。类型名在运行时不可访问
   - 不支持继承的自定义类型
   - 是一个初始化工具。使用脚本创建节点
   - 允许用户定义图标
   - 适用于所有脚本语言
   - 使用 `EditorPlugin.add_custom_type` 设置

2. **脚本类**
   - 编辑器和运行时都可访问
   - 完整显示继承关系
   - 使用脚本创建节点，但也可以从编辑器更改类型或扩展类型
   - 编辑器了解脚本、脚本类和引擎 C++ 类之间的继承关系
   - 允许用户定义图标

### Script 与 PackedScene 的性能

选择场景和脚本时要考虑的最后一个方面是执行速度。随着对象大小的增加，创建和初始化它们所需的脚本大小也会增长大得多。创建节点层次结构证明了这一点。

## 自动加载与常规节点

### 切割音频问题

其他引擎鼓励使用创建管理器类、单例，它们将大量功能组织到一个全局可访问的对象中。由于节点树和信号，Godot 提供了许多避免全局状态的方法。

例如，假设我们正在构建一个平台游戏，想要收集播放声音效果的硬币。有一个节点可以实现这个功能：`AudioStreamPlayer`。但是，如果在 `AudioStreamPlayer` 已经播放声音时调用它，新声音会中断第一个。

一个解决方案是编写一个全局的、自动加载的声音管理器类。它生成一个 `AudioStreamPlayer` 节点池，在每个新的音效请求时循环使用。假设我们称这个类为 `Sound`，你可以通过调用 `Sound.play("coin_pickup.ogg")` 从项目的任何地方使用它。

这在短期内解决了问题，但会导致更多问题：
1. **全局状态**：一个对象现在负责所有对象的数据。如果 `Sound` 类有错误或没有可用的 AudioStreamPlayer，所有调用它的节点都可能崩溃
2. **全局访问**：现在任何对象都可以从任何地方调用 `Sound.play(sound_path)`，不再容易找到错误的来源
3. **全局资源分配**：从一开始存储 `AudioStreamPlayer` 节点池，你可能太少而面临错误，或者太多而使用比你需要的更多内存

相比之下，每个场景保持自己需要的尽可能多的 `AudioStreamPlayer` 节点：
1. 每个场景管理自己的状态信息。如果数据有问题，只会导致该场景出现问题
2. 每个场景只访问自己的节点。现在，如果有错误，很容易找到哪个节点有问题
3. 每个场景精确分配所需的资源量

### 管理共享功能或数据

使用 Autoload 的另一个原因可能是你想在多个场景中重用相同的方法或数据。

对于函数，你可以使用 `class_name` 关键字在 GDScript 中创建一种新的 `Node` 类型，为单个场景提供该功能。

对于数据，你可以：
1. 创建一种新的 `Resource` 类型来共享数据
2. 将数据存储在每个节点都有访问权限的对象中，例如使用 `owner` 属性访问场景的根节点

### 何时应使用自动加载

GDScript 支持使用 `static func` 创建静态函数。当与 `class_name` 结合使用时，可以创建辅助函数库，而无需创建实例来调用它们。

静态函数的限制是它们不能引用成员变量、非静态函数或 `self`。

从 Godot 4.1 开始，GDScript 还支持使用 `static var` 的静态变量。这意味着你现在可以在类的实例之间共享变量，而无需创建单独的自动加载。

但是，对于具有广泛范围的系统，自动加载的节点可以简化你的代码。如果自动加载管理自己的信息而不侵入其他对象的数据，那么它是创建处理广泛范围任务系统的绝佳方式，例如任务或对话系统。

## 数据偏好

### 数组、字典、对象

Godot 在脚本 API 中将所有变量存储在 `Variant` 类中。变体可以存储与变体兼容的数据结构，如 `Array` 和 `Dictionary` 以及 `Objects`。

**Array**：
- Godot 将 Array 实现为 Vector。引擎将 Array 内容存储在连续的内存部分中
- **迭代**：最快。非常适合循环
- **插入、擦除、移动**：取决于位置。通常较慢
  - 从末尾快速添加/删除
  - 从任意位置慢速添加/删除
  - 从最前面最慢添加/删除
- **获取、设置**：按位置最快
- **查找**：最慢。识别值的索引/位置

**Dictionary**：
- Godot 将 Dictionary 实现为 HashMap
- **迭代**：快
- **插入、擦除、移动**：最快
- **获取、设置**：最快（按键查找）
- **查找**：最慢。识别值的键

**Object**：
- Object 实现为愚蠢但动态的数据内容容器
- 每次执行这些多源查询之一时，它会运行几个迭代循环和 HashMap 查找
- 查询是取决于对象继承层次结构大小的线性时间操作

### 枚举：整数 VS 字符串

GDScript 允许使用整数或字符串作为枚举值（后者仅在使用 `@export_enum` 注释时）。

简短的回答是："使用你更舒服的那个"。这是 GDScript 特有的功能，而不是一般的 Godot 脚本。

在技术上，整数比较（常数时间）会比字符串比较（线性时间）更快。如果你想保持其他语言的约定，那么应该使用整数。

使用整数的主要问题出现在你想*打印*枚举值时。作为整数，尝试打印 `MY_ENUM` 会打印 `5` 或其他数字，而不是像 `"MyEnum"` 这样的东西。

### AnimatedTexture vs. AnimatedSprite2D vs. AnimationPlayer vs. AnimationTree

在什么情况下应该使用 Godot 的每个动画类？

- **AnimatedTexture**：是一种纹理，引擎将其绘制为动画循环而不是静态图像
  - 可以控制移动纹理每个部分的速率（FPS）
  - 包含在纹理中的区域数量（帧）
  - 是 Resource 而不是 Node

- **AnimatedSprite2D**：与 SpriteFrames 资源结合，允许通过精灵表创建各种动画序列，在动画之间翻转，并控制它们的速度、区域偏移和方向
  - 适用于控制基于 2D 帧的动画
  - 如果需要触发与动画变化相关的其他效果，需要与 AnimationPlayer 结合使用

- **AnimationPlayer**：需要用来设计各个单独的动画序列
  - 适用于更复杂的 2D 动画系统，如剪纸动画、2D 网格动画等

- **AnimationTree**：适用于需要混合动画、在动画之间实现平滑过渡的情况

## Godot接口

### 获取对象引用

对于所有 Object，引用它们的最基本方法是从另一个获取的实例获取对现有对象的引用。

```gdscript
var obj = node.object      # 属性访问
var obj = node.get_object()  # 方法访问
```

对于 RefCounted 对象也是如此。虽然用户经常以这种方式访问 Node 和 Resource，但还有其他措施可用。

你可以通过加载访问获取 Resources：

```gdscript
# 在场景加载期间加载资源
var preres = preload(path)

# 当程序到达语句时加载资源
var res = load(path)

# 按照约定，用户使用 PascalCase 名称加载场景和脚本
const MyScene = preload("my_scene.tscn")
const MyScript = preload("my_script.gd")
```

### 从对象访问数据或逻辑

一旦有了对对象的引用，就可以访问其数据和方法：

```gdscript
# 访问属性
var value = obj.property

# 调用方法
obj.method()
```

## Godot通知

### 对比 _process、_physics_process、*_input

- **`_process()`**：当需要帧率相关的帧间增量时间时使用
  - 如果需要尽可能频繁地更新对象数据，这是正确的地方
  - 递归逻辑检查和数据缓存通常在这里执行

- **`_physics_process()`**：当需要帧率无关的帧间增量时间时使用
  - 如果代码需要随时间一致更新，无论时间推进多快或多慢，这是正确的地方
  - 递归运动学和对象变换操作应该在这里执行
  - 为获得最佳性能，应避免在这些回调期间进行输入检查

- **`*_input()`** 回调只在引擎实际检测到输入的帧中触发
  - `_process()` 和 `_physics_process()` 会在每个机会触发（默认情况下它们不"休息"）

### 对比 _init、初始化、导出

- **`_init()`**：如果脚本初始化自己的节点子树（没有场景），代码应该在这里执行
  - 在 `_enter_tree()` 或 `_ready()` 之前触发
  - 在脚本创建并初始化其属性之后触发

实例化场景时，属性值将按以下顺序设置：
1. **初始值分配**：属性被分配其初始化值，如果未指定则为其默认值
2. **`_init()` 分配**：属性的值被 `_init()` 中的任何分配替换，触发 setter
3. **导出值分配**：导出属性的值再次被检查器中设置的任何值替换，触发 setter

### 对比 _ready、_enter_tree、NOTIFICATION_PARENTED

当实例化连接到第一个执行场景的场景时，Godot 将实例化节点树（进行 `_init()` 调用）并从根向下构建树。这会导致 `_enter_tree()` 调用向下级联。一旦树完成，叶节点调用 `_ready`。节点在其所有子节点完成调用它们的之后调用此方法。这导致反向级联回到树的根。

如果需要触发节点与另一个节点父级相关的行为，无论它是否作为主/活动场景的一部分发生，都可以使用 `PARENTED` 通知。

## 逻辑偏好

### 先添加节点还是先修改属性？

从脚本在运行时初始化节点时，可能需要更改节点的名称或位置等属性。一个常见的两难选择是，应该在什么时候更改这些值？

**最佳实践是在将节点添加到场景树之前更改其值。** 某些属性的 setter 有更新其他相应值的代码，而这些代码可能很慢！

### 加载 VS 预加载

在 GDScript 中，存在全局 `preload` 方法。它尽可能早地加载资源，以前置"加载"操作，避免在性能敏感代码中间加载资源。

`preload` 在脚本加载时处理所有加载。预加载很有用，但有时你可能不希望这样：

1. 如果你无法确定脚本何时可能加载，那么预加载资源（特别是场景或脚本）可能导致意想不到的进一步加载
2. 如果其他东西可能替换该值（如场景的导出初始化），那么预加载该值没有意义
3. 如果你只希望'导入'另一个类资源（脚本或场景），那么使用预加载常量通常是最好的选择

### 大型关卡：静态 VS 动态

如果你正在创建一个大型关卡，哪种情况最合适？应该将关卡创建为一个静态空间吗？还是应该根据需要加载关卡并移动世界内容？

简单的答案是："当性能需要时。"

与两种选项相关的两难选择是年龄较大的编程选择之一：是优化内存而不是速度，还是反之？

天真的答案是使用一次性加载所有内容的静态关卡。但是，根据项目的不同，这可能会消耗大量内存。浪费用户的 RAM 会导致程序运行缓慢或因计算机同时尝试执行的所有其他操作而完全崩溃。

最好的选择是：
1. 对较小的游戏使用静态关卡
2. 如果你有时间/资源开发中/大型游戏，创建一个库或插件来编码节点和资源的管理
3. 为中/大型游戏编码动态逻辑，因为你有编码技能，但没有时间或资源来完善代码

## 项目组织

### 组织

Godot 本质上是基于场景的，并按原样使用文件系统，没有元数据或资源数据库。

与其他引擎不同，许多资源包含在场景本身中，因此文件系统中的文件数量相当少。

考虑到这一点，最常见的方法是将资产尽可能接近场景分组；当项目增长时，这使其更易于维护。

作为一个例子，通常可以将基本资产（如精灵图像、3D 模型网格、材料和音乐等）放在一个文件夹中。然后可以使用单独的文件夹来存储使用它们的构建关卡。

```
/project.godot
/docs/.gdignore  # 见下面的"忽略特定文件夹"
/docs/learning.html
/models/town/house/house.dae
/models/town/house/window.png
/models/town/house/door.png
/characters/player/cubio.dae
/characters/player/cubio.png
/characters/enemies/goblin/goblin.dae
/characters/enemies/goblin/goblin.png
/characters/npcs/suzanne/suzanne.dae
/characters/npcs/suzanne/suzanne.png
/levels/riverdale/riverdale.scn
```

### 风格指南

为保持项目间的一致性，建议遵循以下准则：

- 对文件夹和文件名使用 **snake_case**（C# 脚本除外）。这避免了在 Windows 上导出项目后可能出现的区分大小写问题
- 对节点名使用 **PascalCase**，因为这符合内置节点的大小写
- 通常，将第三方资源保留在顶级的 `addons/` 文件夹中，即使它们不是编辑器插件
- 有一些例外；例如，如果你使用角色的第三方游戏资产，将它们包含在与角色场景和脚本相同的文件夹中更有意义

### 忽略特定文件夹

要防止 Godot 导入特定文件夹中包含的文件，请在文件夹中创建一个名为 `.gdignore` 的空文件（前导 `.` 是必需的）。这对于加快初始项目导入很有用。

一旦文件夹被忽略，就无法再使用 `load()` 和 `preload()` 方法加载该文件夹中的资源。忽略文件夹也会自动将其从文件系统停靠栏中隐藏，这对于减少混乱很有用。

### 大小写敏感

Windows 和最近的 macOS 版本默认使用区分大小写的文件系统，而 Linux 发行版默认使用区分大小写的文件系统。这在导出项目后可能会导致问题，因为 Godot 的 PCK 虚拟文件系统是区分大小写的。

为避免这种情况，建议坚持对项目中的所有文件使用 `snake_case` 命名（以及小写字符）。

## 总结

Godot 的最佳实践围绕以下几个核心原则：

1. **保持场景的独立性和可重用性**：设计场景时尽量减少对外部环境的依赖
2. **合理使用脚本和场景**：理解各自的优缺点，在合适的场景使用
3. **谨慎使用全局状态**：避免过度依赖 Autoload，优先使用局部和上下文相关的解决方案
4. **选择合适的数据结构**：根据使用场景选择 Array、Dictionary 或 Object
5. **良好的项目组织**：遵循命名约定，保持文件结构清晰
6. **理解生命周期**：正确使用 `_init`、`_ready`、`_process` 等回调函数

遵循这些最佳实践将帮助你创建更易维护、可扩展和高效的 Godot 项目。